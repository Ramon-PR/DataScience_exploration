"""Pytorch Datasets that provides signals from DB_microphone classes containing RIR signals."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/datasets/01_RIR_torch_datasets.ipynb.

# %% auto 0
__all__ = ['DS_random_pick']

# %% ../../nbs/datasets/01_RIR_torch_datasets.ipynb 3
from .mics_databases import ZeaRIR, MeshRIR
from .mics_databases import DB_microphones
from torch.utils.data import Dataset

import matplotlib.pyplot as plt
import torch
import numpy as np
from typing import List

# %% ../../nbs/datasets/01_RIR_torch_datasets.ipynb 12
import math 
import random

# %% ../../nbs/datasets/01_RIR_torch_datasets.ipynb 13
class DS_random_pick(torch.utils.data.Dataset):
    def __init__(
        self,
        mic_database: DB_microphones, 
        n_ref_mics: int = 4,  # number of mics I will pick as my environment to interpolate
        max_combinations: int = 1000,  # number of maximum combinations
    ):
        super().__init__()
        self.db = mic_database
        self.n_ref_mics = n_ref_mics
        self.max_combinations = max_combinations

        # number of combinations without replacement of n elements in groups of r : n!/(r!*(n-r)!)
        n = self.db.n_mics
        r = self.n_ref_mics
        n_comb = int(math.factorial(n) / math.factorial(n - r) / math.factorial(r))
        self.len_comb_dataset = min(n_comb, self.max_combinations)

    def __len__(self):
        return self.len_comb_dataset

    def __getitem__(self, idx):
        ids = random.sample(range(self.db.n_mics), self.n_ref_mics + 1)

        signals = [self.db.get_mic(i) for i in ids]
        positions = [self.db.get_pos(i) for i in ids]
        times = [self.db.get_time(i) for i in ids]

        env = dict(
             signal=torch.from_numpy(np.stack(signals[1:]).astype(np.float32)),
             time=torch.from_numpy(np.stack(times[1:]).astype(np.float32)),
             position=torch.from_numpy(np.stack(positions[1:]).astype(np.float32)),
             )
        
        target = dict(
             signal=torch.from_numpy(np.array(signals[0]).astype(np.float32)),
             time=torch.from_numpy(np.array(times[0]).astype(np.float32)),
             position=torch.from_numpy(np.array(positions[0]).astype(np.float32)),
             )
                   
        return env, target

# %% ../../nbs/datasets/01_RIR_torch_datasets.ipynb 16
import torch
import lightning.pytorch as L
from torch.utils.data import random_split, ConcatDataset, DataLoader
from typing import List

